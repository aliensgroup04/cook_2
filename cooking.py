# -*- coding: utf-8 -*-
"""cooking.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EZKm1yMTM1n8IhHb5SaE6iJwGisqZORi
"""
import streamlit as st
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import PydanticOutputParser
from pydantic import BaseModel, Field, ValidationError
from typing import List

class Recipe(BaseModel):
    ingredients: List[str] = Field(description="List of ingredients for preparing the dish")
    process: List[str] = Field(description="Steps to follow for preparing the dish")
    varieties: List[str] = Field(description="List of names of similar varieties to that dish")
# Output parser
output_parser = PydanticOutputParser(pydantic_object=Recipe)

model = ChatGoogleGenerativeAI(model="gemini-1.5-pro", google_api_key="AIzaSyCBhbuJbxjlghoZ3X1HQhS_qwuMpSE1wC0")

# Prompt Template
prompt_template = ChatPromptTemplate(
    messages=[
        (
            "system",
            """You are a helpful AI Chef Assistant.
            Given a dish name by the user, you provide the process of preparation step by step along with ingredients.
            Output Format Instructions:
            {output_format_instructions}""",
        ),
        ("human", "Give me the recipe and step-by-step instructions for cooking {dish_name}."),
    ],
    partial_variables={
        "output_format_instructions": output_parser.get_format_instructions()
    },
)

# Chain definition
chain = prompt_template | model | output_parser

# Streamlit UI
st.title("üçΩÔ∏è AI Chef Assistant")

dish_name = st.text_input("Enter a dish name", placeholder="E.g., Pasta, Biryani")

if st.button("Get Recipe") and dish_name:
    st.subheader(f"üçΩÔ∏è Recipe for {dish_name}")

    with st.spinner("Fetching recipe...‚è≥"):
        response_text = ""
        for chunk in chain.stream({"dish_name": dish_name}):
            response_text += chunk  # Collect streamed text
        try:
            recipe = output_parser.parse(response_text)  # Parse full response
        except Exception as e:
            st.error(f"Error parsing recipe: {e}")
            recipe = None

    # Display Recipe
    if recipe:
        st.subheader("ü•ï Ingredients:")
        st.markdown("\n".join(f"- {i}" for i in recipe.ingredients))

        st.subheader("üë®‚Äçüç≥ Preparation Steps:")
        st.markdown("\n".join(f"{idx + 1}. {step}" for idx, step in enumerate(recipe.process)))

        if recipe.varieties:
            st.subheader("üçΩÔ∏è Similar Varieties:")
            st.markdown("\n".join(f"- {v}" for v in recipe.varieties))

            # Let user choose a variety
            variety_name = st.selectbox("Try a variety:", ["Select"] + recipe.varieties)
            if st.button("Get Variety Recipe") and variety_name != "Select":
                st.subheader(f"üçΩÔ∏è Recipe for {variety_name}")
                with st.spinner(f"Fetching recipe for {variety_name}...‚è≥"):
                    variety_response = ""
                    for chunk in chain.stream({"dish_name": variety_name}):
                        variety_response += chunk
                    try:
                        variety_recipe = output_parser.parse(variety_response)
                    except Exception as e:
                        st.error(f"Error parsing variety recipe: {e}")
                        variety_recipe = None

                if variety_recipe:
                    st.subheader("ü•ï Ingredients:")
                    st.markdown("\n".join(f"- {i}" for i in variety_recipe.ingredients))
                    st.subheader("üë®‚Äçüç≥ Preparation Steps:")
                    st.markdown("\n".join(f"{idx + 1}. {step}" for idx, step in enumerate(variety_recipe.process)))

st.markdown("---")
st.markdown("Chef Assistant Made by Suman", unsafe_allow_html=True)
