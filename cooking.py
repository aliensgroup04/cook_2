# -*- coding: utf-8 -*-
"""cooking.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EZKm1yMTM1n8IhHb5SaE6iJwGisqZORi
"""
import streamlit as st
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import PydanticOutputParser
from pydantic import BaseModel, Field, ValidationError
from typing import List

class Recipe(BaseModel):
    ingredients: List[str] = Field(description="List of ingredients for preparing the dish")
    process: List[str] = Field(description="Steps to follow for preparing the dish")
    varieties: List[str] = Field(description="List of names of similar varieties to that dish")
# Output parser
output_parser = PydanticOutputParser(pydantic_object=Recipe)

model = ChatGoogleGenerativeAI(model="gemini-1.5-pro", google_api_key="AIzaSyCBhbuJbxjlghoZ3X1HQhS_qwuMpSE1wC0")

# Prompt Template
prompt_template = ChatPromptTemplate(
    messages=[
        (
            "system",
            """You are a helpful AI Chef Assistant.
            Given a dish name by the user, you provide the process of preparation step by step along with ingredients.
            Output Format Instructions:
            {output_format_instructions}""",
        ),
        ("human", "Give me the recipe and step-by-step instructions for cooking {dish_name}."),
    ],
    partial_variables={
        "output_format_instructions": output_parser.get_format_instructions()
    },
)

# Chain definition
chain = prompt_template | model | output_parser

# Streamlit UI
st.title("Chef Assistant üçΩÔ∏è")
user_input = st.text_input("Enter your dish name", placeholder="E.g., Pasta, Biryani")

if st.button("Get Recipe"):
    if user_input:
        with st.spinner("Fetching recipe...‚è≥"):
            input_data = {"dish_name": user_input}

            # Streamlit placeholders for real-time updates
            ingredients_placeholder = st.empty()
            process_placeholder = st.empty()
            varieties_placeholder = st.empty()

            try:
                recipe = Recipe(ingredients=[], process=[], varieties=[])

                for chunk in chain.stream(input_data):
                    if isinstance(chunk, Recipe):
                        # Remove duplicates & clean up data
                        recipe.ingredients = list(dict.fromkeys(filter(None, [str(i).strip() for i in recipe.ingredients + chunk.ingredients])))
                        recipe.process = list(dict.fromkeys(filter(None, [str(step).strip() for step in recipe.process + chunk.process])))
                        recipe.varieties = list(dict.fromkeys(filter(None, [str(v).strip() for v in recipe.varieties + chunk.varieties])))

                        # Display Ingredients
                        with ingredients_placeholder.container():
                            st.subheader("ü•ï Ingredients:")
                            st.markdown("\n".join(f"- {i}" for i in recipe.ingredients if i.strip()))

                        # Display Process Steps
                        with process_placeholder.container():
                            st.subheader("üë®‚Äçüç≥ Preparation Steps:")
                            st.markdown("\n".join(f"{idx + 1}. {step}" for idx, step in enumerate(recipe.process) if step.strip()))

                        # Display Varieties
                        with varieties_placeholder.container():
                            if recipe.varieties:
                                st.subheader("üçΩÔ∏è Similar Varieties:")
                                st.markdown("\n".join(f"- {v}" for v in recipe.varieties if v.strip()))

                # Ask user if they want to check a variety recipe
                if recipe.varieties:
                    st.markdown("### Would you like to try any variety? Enter its name below:")
                    variety_choice = st.text_input("Enter a variety name", placeholder="E.g., Chicken Biryani, Alfredo Pasta")

                    if st.button("Get Variety Recipe"):
                        if variety_choice.strip():
                            with st.spinner(f"Fetching recipe for {variety_choice}...‚è≥"):
                                input_data = {"dish_name": variety_choice}
                                try:
                                    variety_recipe = chain.invoke(input_data)

                                    if isinstance(variety_recipe, Recipe):
                                        st.subheader(f"üçΩÔ∏è Recipe for {variety_choice}")

                                        st.subheader("ü•ï Ingredients:")
                                        st.markdown("\n".join(f"- {i}" for i in variety_recipe.ingredients if i.strip()))

                                        st.subheader("üë®‚Äçüç≥ Preparation Steps:")
                                        st.markdown("\n".join(f"{idx + 1}. {step}" for idx, step in enumerate(variety_recipe.process) if step.strip()))

                                except ValidationError as e:
                                    st.error("Error fetching variety recipe!")
                                    st.write(str(e))
                        else:
                            st.warning("Please enter a variety name!")

            except ValidationError as e:
                st.error("Error parsing the response. Try again!")
                st.write(str(e))
    else:
        st.warning("Please enter a dish name!")

st.markdown("<hr>", unsafe_allow_html=True)
st.markdown("<h5 style='color: gray;'>Chef Assistant made by Suman</h5>", unsafe_allow_html=True)
